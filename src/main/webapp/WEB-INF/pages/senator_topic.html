<html>
<head>
<title>test</title>
<!-- CSS -->

<link href="../../resources/css/visualize.css" rel="stylesheet">
<script src="../../resources/js/d3.v3.min.js"></script>
<script src="../../resources/js/jquery-1.11.0.min.js"></script>
</head>
<body>
	<script>
		var MAX_SENATOR = 20;
		var svgWidth = 980;
		var svgHeight = 500;
		var margin = {
			top : 60,
			right : 80,
			bottom : 120,
			left : 120
		}, width = svgWidth - margin.left - margin.right, height = svgHeight
				- margin.top - margin.bottom;

		//create test data
		var data = [];
		var numDataPoints = 100;
		var numTopics = 20;
		var numSenators = 100;
		var numTimeRanges = 5;
		
		for(var k=0;k<numTimeRanges;k++){
		var subData=[];
		
		for (var i = 0; i < numDataPoints; i++) {
			var senator = (i % numSenators) + 1;

			for (var j = 0; j < numTopics; j++) {
				var topic = j+1;// Math.floor(Math.random() * numTopics) + 1;

				var prop = Math.random();
				subData.push([ senator, "Topic " + topic, prop ]);
			}
			data[k] =subData;
		}

		}
		var startPoint = 0;
		var timeRange =0
		var dataset = interpolateData(data, startPoint,timeRange);
		draw(dataset);

		/*
		var uniqTopics = [];

		$.each(dataset, function(index, d) {

			if ($.inArray(d.topic, uniqTopics) === -1) {
				uniqTopics.push(d.topic);
			}
		});
		var topicLen = uniqTopics.length;
		var moveDown = height / (2 * (topicLen - 1))
		var moveRight = moveDown;

		var maxX = d3.max(dataset, function(d) {
			return d.senator;
		});

		var minX = d3.min(dataset, function(d) {
			return d.senator;
		});

		var maxP = d3.max(dataset, function(d) {
			return d.prop;
		});

		var xScale = d3.scale.linear();
		var yScale = d3.scale.ordinal().rangePoints(
				[ height + moveDown, moveDown ]);

		var rScale = d3.scale.linear();

		var c = d3.scale.category20c();

		xScale.domain([ minX, maxX ]).rangeRound(
				[ moveRight, width + moveRight ]);

		yScale.domain(dataset.sort(
				function(a, b) {
					return d3.descending(
							parseInt(a.topic.replace("Topic ", "")),
							parseInt(b.topic.replace("Topic ", "")));
				}).map(function(d) {
			return d.topic;
		}));

		rScale.domain([ 0, maxP ]).rangeRound([ 2, 10 ]);

		var xAxis = d3.svg.axis().scale(xScale).orient("top")
				.ticks(MAX_SENATOR);
		var yAxis = d3.svg.axis().scale(yScale).orient("left");
		// Add an SVG element with the desired dimensions and margin.
		var svg = d3.select("body").append("svg").attr("class", "main").attr(
				"width", svgWidth).attr("height", svgHeight).append("g").attr(
				"transform",
				"translate(" + margin.left + "," + margin.top + ")");

		// measure line
		// define the measure line
		var measureLine = d3.svg.line().defined(function(d) {
			return d.measure != null;
		}).x(function(d) {
			return xScale(d.line);
		}).y(function(d) {
			return yScale(d.measure);
		});

		for (var i = 0; i < topicLen; i++) {

			var lineData = [ {
				"line" : minX,
				"measure" : uniqTopics[i]
			}, {
				"line" : maxX,
				"measure" : uniqTopics[i]
			} ];

			svg.append("path").attr("class", "measureLine").attr("d",
					measureLine(lineData));
		}

		var circles = svg.selectAll("circle").data(dataset).enter().append(
				"circle");

		circles.attr("cx", function(d) {
			return xScale(d.senator);
		}).attr("cy", function(d) {
			return yScale(d.topic);
		}).attr("r", function(d, i) {
			return rScale(d.prop);
		}).style("fill-opacity", ".5");

		//add x-axis
		svg.append("g").attr("class", "x axis").attr("transform",
				"translate(0, " + 0 + ")").call(xAxis).selectAll("text").style(
				"font-size", "12px").style("text-anchor", "end").attr("dx",
				"30").attr("dy", "0").attr("transform", function(d) {
			return "rotate(-50)"
		});
		;

		svg.append("g").attr("class", "y axis").attr("transform",
				"translate(0 ,0)").call(yAxis);

		svg.selectAll("g.y.axis path, g.y.axis line").style("display", "none");

		svg.selectAll("g.y.axis .tick").style("fill", function(d, i) {
			return c(i);
		});
		
		 */

		//This is the accessor function we talked about above
		var lineFunction = d3.svg.line().x(function(d) {
			return d.x;
		}).y(function(d) {
			return d.y;
		}).interpolate("linear");

		//===== set cursor
		function setcursor(cursor) {
			d3.select("body").style("cursor", cursor);
		}

		var svgLeft = d3.select("body").append("svg")
				.attr("class", "arrowleft").attr("width", 40).attr("height",

				svgHeight);
		lineData = [ {
			"x" : 40,
			"y" : 0
		}, {
			"x" : 0,
			"y" : svgHeight / 2
		}, {
			"x" : 40,
			"y" : svgHeight
		} ];

		//The line SVG Path we draw
		svgLeft.append("path").attr("d", lineFunction(lineData)).attr("stroke",
				"#ccc").attr("stroke-width", 1).attr("fill", "#ccc");

		svgLeft.append("text").attr("x", 20).attr("y", svgHeight / 2).attr(
				"text-anchor", "middle").text("-10");

		var svgTop = d3.select("body").append("svg").attr("class", "arrowtop")
				.attr("width", svgWidth).attr("height", 40);

		lineData = [ {
			"x" : 0,
			"y" : 40
		}, {
			"x" : svgWidth / 2,
			"y" : 0
		}, {
			"x" : svgWidth,
			"y" : 40
		} ];

		//The line SVG Path we draw
		svgTop.append("path").attr("d", lineFunction(lineData)).attr("stroke",
				"#ccc").attr("stroke-width", 1).attr("fill", "#ccc");

		svgTop.append("text").attr("x", svgWidth / 2).attr("y", 20).attr(
				"text-anchor", "middle").text("Previous Time");

		var svgRight = d3.select("body").append("svg").attr("class",
				"arrowright").attr("width", 40).attr("height", svgHeight);

		//try do draw a line here
		//The data for our line
		var lineData = [ {
			"x" : 0,
			"y" : 0
		}, {
			"x" : 40,
			"y" : svgHeight / 2
		}, {
			"x" : 0,
			"y" : svgHeight
		} ];

		svgRight.append("path").attr("d", lineFunction(lineData)).attr(
				"stroke", "#ccc").attr("stroke-width", 1).attr("fill",
				"#ccc");

		svgRight.append("text").attr("x", 20).attr("y", svgHeight / 2).attr(
				"text-anchor", "middle").text("+10");

		//END

		var svgBottom = d3.select("body").append("svg").attr("class",
				"arrowbottom").attr("width", svgWidth).attr("height", 40);

		lineData = [ {
			"x" : 0,
			"y" : 0
		}, {
			"x" : svgWidth / 2,
			"y" : 40
		}, {
			"x" : svgWidth,
			"y" : 0
		} ];

		//The line SVG Path we draw
		svgBottom.append("path").attr("d", lineFunction(lineData)).attr(
				"stroke", "#ccc").attr("stroke-width", 1).attr("fill",
				"#ccc");

		svgBottom.append("text").attr("x", svgWidth / 2).attr("y", 20).attr(
				"text-anchor", "middle").text("Next Time");

		svgLeft.on("mouseover", function() {
			setcursor("pointer");
		}).on("mouseout", function() {
			setcursor("default");
		});

		svgTop.on("mouseover", function() {
			setcursor("pointer");
		}).on("mouseout", function() {
			setcursor("default");
		});

		svgRight.on("mouseover", function() {
			setcursor("pointer");
		}).on("mouseout", function() {
			setcursor("default");
		});

		svgBottom.on("mouseover", function() {
			setcursor("pointer");
		}).on("mouseout", function() {
			setcursor("default");
		});

		svgRight.on("click", function() {
			if (startPoint <= numDataPoints - 2 * MAX_SENATOR) {
				startPoint += MAX_SENATOR;
				
				dataset = interpolateData(data, startPoint,timeRange);
				draw(dataset);
			}
		});

		svgLeft.on("click", function() {
			if (startPoint >= MAX_SENATOR) {
				startPoint -= MAX_SENATOR;
				dataset = interpolateData(data, startPoint,timeRange);
				draw(dataset);
			}
		});
		
		svgTop.on("click", function() {
			if (timeRange >=1) {
				timeRange-=1;
				dataset = interpolateData(data, startPoint,timeRange);
				draw(dataset);
			}
		});
		
		svgBottom.on("click", function() {
			if (timeRange <numTimeRanges-1) {
				timeRange+=1;
				dataset = interpolateData(data, startPoint,timeRange);
				draw(dataset);
			}
		});

		function interpolateData(inputData, startPoint,timeRange) {
			var data = inputData[timeRange].slice(numTopics* startPoint, numTopics*( startPoint +
					
					MAX_SENATOR));

			return $.map(data, function(d) {

				return {
					senator : d[0],
					topic : d[1],
					prop : d[2] * d[2]
				};

			});

		}

		function reset(){
			margin = {
					top : 60,
					right : 80,
					bottom : 120,
					left : 120
				}, width = svgWidth - margin.left - margin.right, height = svgHeight
						- margin.top - margin.bottom;

		}
		function draw(dataset) {
			d3.select("svg .main").data([]).exit().remove();
			var uniqTopics = [];

			$.each(dataset, function(index, d) {

				if ($.inArray(d.topic, uniqTopics) === -1) {
					uniqTopics.push(d.topic);
				}
			});
			var topicLen = uniqTopics.length;
			var moveDown = 30+ height / ((topicLen - 1))
			var moveRight = moveDown;

			var maxX = d3.max(dataset, function(d) {
				return d.senator;
			});

			var minX = d3.min(dataset, function(d) {
				return d.senator;
			});

			var maxP = d3.max(dataset, function(d) {
				return d.prop;
			});

			var xScale = d3.scale.linear();
			var yScale = d3.scale.ordinal().rangePoints(
					[ height + moveDown, moveDown ]);

			var rScale = d3.scale.linear();

			var c = d3.scale.category20();

			xScale.domain([ minX, maxX ]).rangeRound(
					[ moveRight, width + moveRight ]);

			yScale.domain(dataset.sort(
					function(a, b) {
						return d3.descending(parseInt(a.topic.replace("Topic ",
								"")), parseInt(b.topic.replace("Topic ", "")));
					}).map(function(d) {
				return d.topic;
			}));

			rScale.domain([ 0, maxP ]).rangeRound([ 2, 10 ]);

			var xAxis = d3.svg.axis().scale(xScale).orient("top").ticks(
					MAX_SENATOR).tickFormat(function(d) { return "senator "+ d; });
			var yAxis = d3.svg.axis().scale(yScale).orient("left");
			// Add an SVG element with the desired dimensions and margin.
			var svg = d3
					.select("body")
					.append("svg")
					.attr("class", "main")
					.attr("width", svgWidth)
					.attr("height", svgHeight)
					.append("g")
					.attr("transform",
							"translate(" + margin.left + "," + margin.top + ")");

			// measure line
			// define the measure line
			var measureLine = d3.svg.line().defined(function(d) {
				return d.measure != null;
			}).x(function(d) {
				return xScale(d.line);
			}).y(function(d) {
				return yScale(d.measure);
			});

			for (var i = 0; i < topicLen; i++) {

				var lineData = [ {
					"line" : minX,
					"measure" : uniqTopics[i]
				}, {
					"line" : maxX,
					"measure" : uniqTopics[i]
				} ];

				svg.append("path").attr("class", "measureLine").attr("d",
						measureLine(lineData));
			}

			var circles = svg.selectAll("circle").data(dataset).enter().append(
					"circle");

			circles.attr("cx", function(d) {
				return xScale(d.senator);
			}).attr("cy", function(d) {
				return yScale(d.topic);
			}).attr("r", function(d, i) {
				return rScale(d.prop);
			}).style("fill", function(d, i) {
				return c(d.topic);
			}).style("fill-opacity", ".5");

			//add x-axis
			svg.append("g").attr("class", "x axis").attr("transform",
					"translate(0, " + 0 + ")").call(xAxis).selectAll("text")
					.style("font-size", "12px").style("text-anchor", "end")
					.attr("dx", "60").attr("dy", "0").attr("transform",
							function(d) {
								return "rotate(-50)"
							});
			;

			svg.append("g").attr("class", "y axis").attr("transform",
					"translate(0 ,0)").call(yAxis);

			svg.selectAll("g.y.axis path, g.y.axis line").style("display",
					"none");

			svg.selectAll("g.y.axis .tick").style("fill", function(d, i) {
				return c(i);
			});
			

			svg.on("mousemove", function() {

				//console.log(d3.event);
				if (d3.event.pageY > (40 + svgHeight / 2)) {

					$(".arrowbottom").fadeIn(400);
					$(".arrowtop").fadeOut(400);

				} else {
					$(".arrowtop").fadeIn(400);
					$(".arrowbottom").fadeOut(400);
				}

				if (d3.event.pageX > (40 + svgWidth / 2)) {
					$(".arrowright").fadeIn(400);
					$(".arrowleft").fadeOut(400);
				} else {
					$(".arrowleft").fadeIn(400);
					$(".arrowright").fadeOut(400);
				}

			});
		}
	</script>
</body>
</html>